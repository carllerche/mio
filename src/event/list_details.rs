//! List events generated by the OS in various scenarios, used to determine how
//! Mio can expose them in best possible, cross-platform way.
//!
//! Run using:
//!
//! ```sh
//! cargo test list_event_details -- --nocapture --ignored
//! ```

// NOTE: this code is very ugly and doesn't do proper cleanup (closing of fds
// etc.), only look at this when you want to know what **not** to do.

#![cfg_attr(windows, allow(dead_code))]

use std::fmt::Write;
use std::io;
#[cfg(unix)]
use std::os::unix::io::RawFd;
use std::time::Duration;

#[cfg(windows)]
use crate::sys::afd;
#[cfg(unix)]
use crate::syscall;
#[cfg(unix)]
use crate::unix::SourceFd;
use crate::{event, sys, Events, Interests, Poll, Token};

const TOKEN: Token = Token(0);

const TIMEOUT: Option<Duration> = Some(Duration::from_secs(1));

const DATA: &[u8] = b"hello";

#[test]
#[cfg(not(windows))]
#[ignore = "This is not a test, it just lists OS event details"]
fn list_event_details() {
    let mut poll = Poll::new().unwrap();
    let mut events = Events::with_capacity(16);
    #[cfg(unix)]
    unix_pipe(&mut poll, &mut events).unwrap();
}

#[cfg(unix)]
fn unix_pipe(poll: &mut Poll, events: &mut Events) -> io::Result<()> {
    let mut fds: [RawFd; 2] = [-1; 2];
    syscall!(pipe(fds.as_mut_ptr())).and_then(|_| {
        let r = fds[0];
        let w = fds[1];

        register_and_print(
            poll,
            events,
            &SourceFd(&w),
            Interests::WRITABLE,
            "Unix pipe sender writable",
            || Ok(()),
            || syscall!(write(w, DATA.as_ptr() as *const libc::c_void, DATA.len())),
        )?;

        register_and_print(
            poll,
            events,
            &SourceFd(&r),
            Interests::READABLE,
            "Unix pipe receiver readable",
            || Ok(()),
            || Ok(()),
        )?;

        register_and_print(
            poll,
            events,
            &SourceFd(&w),
            Interests::WRITABLE,
            "Unix pipe sender, receiver closed",
            || syscall!(close(r)),
            || Ok(()),
        )?;

        Ok(())
    })?;

    syscall!(pipe(fds.as_mut_ptr())).and_then(|_| {
        let r = fds[0];
        let w = fds[1];

        register_and_print(
            poll,
            events,
            &SourceFd(&r),
            Interests::READABLE,
            "Unix pipe receiver, sender closed",
            || syscall!(close(w)),
            || Ok(()),
        )?;

        Ok(())
    })
}

/// Registers the `source`, calls `create_event` to create events, polls for the
/// events and print them. Finally it deregisters the source and calls
/// `cleanup`.
fn register_and_print<S, CE, I, C, T>(
    poll: &mut Poll,
    events: &mut Events,
    source: &S,
    interests: Interests,
    desc: &str,
    create_event: CE,
    cleanup: C,
) -> io::Result<T>
where
    S: event::Source,
    CE: FnOnce() -> io::Result<I>,
    C: FnOnce() -> io::Result<T>,
{
    poll.registry().register(source, TOKEN, interests)?;

    let _ = create_event()?;

    poll.poll(events, TIMEOUT)?;
    print_event(desc, events);

    poll.registry().deregister(source)?;

    cleanup()
}

fn print_event(desc: &str, events: &Events) {
    assert!(!events.is_empty());
    for event in events {
        let mut result = String::new();
        write!(result, "{}: ", desc).unwrap(); // alignment
        event_data(&mut result, event.sys());
        println!("{}", result);
    }
}

#[cfg(any(target_os = "android", target_os = "linux", target_os = "solaris"))]
fn event_data(result: &mut String, event: &sys::Event) {
    macro_rules! has_event {
        ($($(#[$target: meta])* $event: ident),+ $(,)*) => {
            $(
                $(#[$target])*
                {
                    if (event.events as libc::c_int & libc::$event) != 0 {
                        write!(result, "{}|", stringify!($event)).unwrap();
                    }
                }
            )+
        };
    }

    has_event!(
        EPOLLIN,
        EPOLLPRI,
        EPOLLOUT,
        EPOLLRDNORM,
        EPOLLRDBAND,
        EPOLLWRNORM,
        EPOLLWRBAND,
        EPOLLMSG,
        EPOLLERR,
        EPOLLHUP,
        EPOLLET,
        EPOLLRDHUP,
        EPOLLONESHOT,
        #[cfg(any(target_os = "linux", target_os = "solaris"))]
        EPOLLEXCLUSIVE,
        #[cfg(any(target_os = "android", target_os = "linux"))]
        EPOLLWAKEUP,
        EPOLL_CLOEXEC,
    );
}

#[cfg(any(
    target_os = "dragonfly",
    target_os = "freebsd",
    target_os = "ios",
    target_os = "macos",
    target_os = "netbsd",
    target_os = "openbsd"
))]
fn event_data(result: &mut String, event: &sys::Event) {
    macro_rules! is_filter {
        ($($(#[$target: meta])* $filter: ident),+ $(,)*) => {
            $(
                $(#[$target])*
                {
                    if event.filter == libc::$filter {
                        write!(result, "{}|", stringify!($filter)).unwrap();
                    }
                }
            )+
        };
    }

    is_filter!(
        EVFILT_READ,
        EVFILT_WRITE,
        EVFILT_AIO,
        EVFILT_VNODE,
        EVFILT_PROC,
        EVFILT_SIGNAL,
        EVFILT_TIMER,
        #[cfg(target_os = "freebsd")]
        EVFILT_PROCDESC,
        #[cfg(any(
            target_os = "freebsd",
            target_os = "dragonfly",
            target_os = "ios",
            target_os = "macos"
        ))]
        EVFILT_FS,
        #[cfg(target_os = "freebsd")]
        EVFILT_LIO,
        #[cfg(any(
            target_os = "freebsd",
            target_os = "dragonfly",
            target_os = "ios",
            target_os = "macos"
        ))]
        EVFILT_USER,
        #[cfg(target_os = "freebsd")]
        EVFILT_SENDFILE,
        #[cfg(target_os = "freebsd")]
        EVFILT_EMPTY,
        #[cfg(target_os = "dragonfly")]
        EVFILT_EXCEPT,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        EVFILT_MACHPORT,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        EVFILT_VM,
    );

    macro_rules! has_flag {
        ($($(#[$target: meta])* $flag: ident),+ $(,)*) => {
            $(
                $(#[$target])*
                {
                    if (event.flags & libc::$flag) != 0  {
                        write!(result, "{}|", stringify!($flag)).unwrap();
                    }
                }
            )+
        };
    }

    has_flag!(
        EV_ADD,
        EV_DELETE,
        EV_ENABLE,
        EV_DISABLE,
        EV_ONESHOT,
        EV_CLEAR,
        EV_RECEIPT,
        EV_DISPATCH,
        #[cfg(target_os = "freebsd")]
        EV_DROP,
        EV_FLAG1,
        EV_ERROR,
        EV_EOF,
        EV_SYSFLAGS,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        EV_FLAG0,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        EV_POLL,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        EV_OOBAND,
        #[cfg(target_os = "dragonfly")]
        EV_NODATA,
    );

    macro_rules! has_fflag {
        ($($(#[$target: meta])* $fflag: ident),+ $(,)*) => {
            $(
                $(#[$target])*
                #[allow(clippy::bad_bit_mask)] // Apparently some flags are zero.
                {
                    if (event.fflags & libc::$fflag) != 0  {
                        write!(result, "{}|", stringify!($fflag)).unwrap();
                    }
                }
            )+
        };
    }

    has_fflag!(
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "ios",
            target_os = "macos"
        ))]
        NOTE_TRIGGER,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "ios",
            target_os = "macos"
        ))]
        NOTE_FFNOP,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "ios",
            target_os = "macos"
        ))]
        NOTE_FFAND,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "ios",
            target_os = "macos"
        ))]
        NOTE_FFOR,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "ios",
            target_os = "macos"
        ))]
        NOTE_FFCOPY,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "ios",
            target_os = "macos"
        ))]
        NOTE_FFCTRLMASK,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "ios",
            target_os = "macos"
        ))]
        NOTE_FFLAGSMASK,
        NOTE_LOWAT,
        NOTE_DELETE,
        NOTE_WRITE,
        #[cfg(target_os = "dragonfly")]
        NOTE_OOB,
        #[cfg(target_os = "openbsd")]
        NOTE_EOF,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_EXTEND,
        NOTE_ATTRIB,
        NOTE_LINK,
        NOTE_RENAME,
        NOTE_REVOKE,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_NONE,
        #[cfg(any(target_os = "openbsd"))]
        NOTE_TRUNCATE,
        NOTE_EXIT,
        NOTE_FORK,
        NOTE_EXEC,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_SIGNAL,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_EXITSTATUS,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_EXIT_DETAIL,
        NOTE_PDATAMASK,
        NOTE_PCTRLMASK,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
        ))]
        NOTE_TRACK,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
        ))]
        NOTE_TRACKERR,
        #[cfg(any(
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
        ))]
        NOTE_CHILD,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_EXIT_DETAIL_MASK,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_EXIT_DECRYPTFAIL,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_EXIT_MEMORY,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_EXIT_CSERROR,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_VM_PRESSURE,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_VM_PRESSURE_TERMINATE,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_VM_PRESSURE_SUDDEN_TERMINATE,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_VM_ERROR,
        #[cfg(any(target_os = "freebsd", target_os = "ios", target_os = "macos"))]
        NOTE_SECONDS,
        #[cfg(any(target_os = "freebsd"))]
        NOTE_MSECONDS,
        #[cfg(any(target_os = "freebsd", target_os = "ios", target_os = "macos"))]
        NOTE_USECONDS,
        #[cfg(any(target_os = "freebsd", target_os = "ios", target_os = "macos"))]
        NOTE_NSECONDS,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        #[cfg(any(target_os = "freebsd", target_os = "ios", target_os = "macos"))]
        NOTE_ABSOLUTE,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_LEEWAY,
        #[cfg(any(target_os = "ios", target_os = "macos"))]
        NOTE_CRITICAL,
        #[cfg(any(target_os = "dragonfly"))]
        NOTE_BACKGROUND,
    );
}

#[cfg(windows)]
fn event_data(result: &mut String, event: &sys::Event) {
    macro_rules! has_event {
        ($($(#[$target: meta])* $event: ident),+ $(,)*) => {
            $(
                $(#[$target])*
                {
                    if event.flags & afd::$event != 0 {
                        write!(result, "{}|", stringify!($event)).unwrap();
                    }
                }
            )+
        };
    }

    has_event!(
        AFD_POLL_RECEIVE,
        AFD_POLL_RECEIVE_EXPEDITED,
        AFD_POLL_SEND,
        AFD_POLL_DISCONNECT,
        AFD_POLL_ABORT,
        AFD_POLL_LOCAL_CLOSE,
        AFD_POLL_ACCEPT,
        AFD_POLL_CONNECT_FAIL,
    );
}
